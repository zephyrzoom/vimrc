/*
 * @author 707<707472783@qq.com>
 * This program searches the shortest path.
 */
#include <vector>
#include <cctype>
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <ctime>

#include "short_path.h"

std::vector<int> findPath(char **topo, int edgeNum, char *demand)
{
    std::vector<int> path;
    int pathWeight = 0xFFFF;

    std::vector<Arc> sortedTopo = sortByIn(topo, edgeNum);

    std::vector<int> dmd = getDemand(demand);
    int start = dmd[0];
    std::vector<Arc> arcs = findArcs(start, sortedTopo);

    // create root from the start.
    Node *root = new Node(NULL, arcs[0].in, 0, arcs);
    root->addExistNode(arcs[0].in);

    time_t t_start,t_end;
    t_start = time(NULL);
    while (root != NULL)
    {
        while (root->notVisit.size() > 0)
        {
            std::vector<Arc>::iterator arc = root->notVisit.begin();
            if (!nodeAlreadyExist(arc->out, root))
            {
                Node *node = insertNode(root, arc, sortedTopo);
                if (node->num == dmd[1])
                {
                    calTheShortestPath(path, node, pathWeight, dmd);
                    delete node;
                    root->notVisit.erase(arc);
                }
                else
                {
                    root->notVisit.erase(arc);
                    root = node;
                }
            }
            else
            {
                root->notVisit.erase(arc);
            }
        }
        Node *toBeDel = root;
        root = root->parent;
        delete toBeDel;
        t_end = time(NULL);
        if (t_end - t_start >= 10)
        {
            return path;
        }
    }
    return path;
}

/*
sort the topo list by in-degree.
use the insert sort algorithm.
 */
std::vector<Arc> sortByIn(char **topo, int edgeNum)
{
    std::vector<Arc> arcs = restore2Int(topo, edgeNum);

    for (std::vector<Arc>::iterator i = arcs.begin()+1; i != arcs.end(); ++i)
    {
        std::vector<Arc>::iterator j = i;
        while (j > arcs.begin() && (j-1)->in > j->in)
        {
            std::swap(*j, *(j-1));
            --j;
        }
    }

    return arcs;
}

/*
change the topo list from char to int.
 */
std::vector<Arc> restore2Int(char **topo, int edgeNum)
{
    std::vector<Arc> arcs;
    for (size_t i = 0; i < edgeNum; ++i)
    {
        int tmpArc[4];
        int used = 0;
        int tmp = 0;
        size_t j = 0;
        while (topo[i][j] != '\0')
        {
            if (isdigit(topo[i][j]))
            {
                tmp = tmp * 10 + (topo[i][j] - '0');
            }
            else
            {
                tmpArc[used++] = tmp;
                tmp = 0;
            }
            ++j;
        }
        tmpArc[used] = tmp;
        Arc arc(tmpArc[0], tmpArc[1], tmpArc[2], tmpArc[3]);
        arcs.push_back(arc);
    }
    return arcs;
}

/*
change the demand from char to int.
 */
std::vector<int> getDemand(char *demand)
{
    std::vector<int> dmd;
    int tmp = 0;
    for (size_t i = 0; i < strlen(demand); ++i)
    {
        if (isdigit(demand[i]))
        {
            tmp = tmp * 10 + (demand[i] - '0');
        }
        else
        {
            dmd.push_back(tmp);
            tmp = 0;
        }
    }
    dmd.push_back(tmp);
    return dmd;
}

/*
find corresponding arcs by the in-degree node number.
 */
std::vector<Arc> findArcs(int inNode, std::vector<Arc> arcs)
{
    std::vector<Arc> found;
    for (std::vector<Arc>::iterator i = arcs.begin(); i != arcs.end(); ++i)
    {
        if (i->in == inNode)
        {
            found.push_back(*i);
        }
    }
    return found;
}

/*
test the node exist or not in the path
by compare the bit position.
 */
bool nodeAlreadyExist(int out, Node *root)
{
    if (root->exist.size() > out/32)
    {
        if ((1 << (out%32) & root->exist[out/32]) > 0)
        {
            return true;
        }
        else
        {
            return false;
        }
    }
    else
    {
        return false;
    }
}


Node *insertNode(Node *root, std::vector<Arc>::iterator &arc, std::vector<Arc> &arcs)
{
    Node *node = new Node(root, arc->out, arc->num,
        arc->weight + root->weight, root->exist,
        findArcs(arc->out, arcs));
    node->addExistNode(arc->out);
    return node;
}

void printPath(std::vector<int> result)
{
    for (std::vector<int>::iterator i = result.begin(); i != result.end(); ++i)
    {
        std::cout << *i << " ";
    }
    std::cout << std::endl;
}

/*
add the node info
to the bit position.
 */
void Node::addExistNode(int num)
{
    int needed = num/32 + 1 - this->exist.size();
    if (needed > 0)
    {
        for (size_t i = 0; i < needed; ++i)
        {
            unsigned int tmp = 0;
            this->exist.push_back(tmp);
        }
    }
    this->exist[num/32] |= (1 << num);
}

void calTheShortestPath(std::vector<int> &path, Node *node,
    int &pathWeight, std::vector<int> &demand)
{

    for (std::vector<int>::iterator j = demand.begin()+2; j != demand.end(); ++j)
    {
        if (!nodeAlreadyExist(*j, node))
        {
            return;
        }
    }
    // // print paths.
    // // temporary.
    // Node *tmp = node;
    // while (tmp != NULL)
    // {
    //     std::cout << tmp->num << " ";
    //     tmp = tmp->parent;
    // }
    // std::cout << std::endl;

    if (path.empty())
    {
        pathWeight = node->weight;
        while (node->parent != NULL)
        {
            path.insert(path.begin(), node->arc);
            node = node->parent;
        }
    }
    else
    {
        if (node->weight < pathWeight)
        {
            pathWeight = node->weight;
            path.clear();
            while (node->parent != NULL)
            {
                path.insert(path.begin(), node->arc);
                node = node->parent;
            }
        }
    }
}